\documentclass[journal,twoside]{JoPhA}

\usepackage{color}
\usepackage{flushend}
\usepackage{fancyvrb}
\usepackage[pdftex]{graphicx}
\usepackage{hyperref}


% declare the path(s) where your graphic files are
\graphicspath{{figures/}}
% and their extensions so you won't have to specify these with
% every instance of \includegraphics
\DeclareGraphicsExtensions{.pdf,.jpeg,.png}


\begin{document}

\title{Cybersecurity in Autonomous Systems: Evaluating the performance of hardened ROS}

\author{Francisco Javier Rodr\'iguez Lera, Jes\'us Balsa, Fernando Casado, Camino Fern\'andez, Francisco Martín Rico, and Vicente Matell\'an
\IEEEcompsocitemizethanks{
Francisco Javier Rodr\'iguez Lera, Jes\'us Balsa, Fernando Casado, Camino Fern\'andez, and Vicente Matell\'an are with the Robotics Group (http://robotica.unileon.es) and the Research Institute on Applied Sciences to Cybersecurity (http://riasc.unileon.es) at Universidad de Le\'on (Spain).

Francisco Martín Rico is with Robotics Lab, Signal Theory, Communications, Telematic Systems and Computation Department at Universidad Rey Juan Carlos, Madrid (Spain).

\IEEEcompsocthanksitem Corresponding author: vicente.matellan@unileon.es}% <-this % is needed.
}






\markboth{Workshop on Physical Agents, M\'alaga 2016}%
{Matell\'an et al: Cybersecurity in ROS}
\maketitle


\begin{abstract}
As robotic systems spread, cybersecurity emerges as major concern. Currently most research autonomous systems are built using the ROS framework, along with other commercial software. 
ROS is a distributed framework where nodes publish information that other nodes consume. 
This model simplifies data communication but poses a major threat because a malicious process could easily interfere the communications, read private messages or even supersede nodes. In this paper we propose that ROS communications should be encrypted. We also measure how encryption affects its performance. We have used three different ciphering techniques: DES, AES and RSA. We have evaluated the performance of the system, both from the computing and the communications point of view. Preliminary results show that symmetric ciphers using private keys impose significant delays.
\end{abstract}


\begin{IEEEkeywords}
Autonomous systems, Cybersecurity, Data security, Cyber-physical systems, ROS, Performance analysis
\end{IEEEkeywords}


\section{Introduction}


% \IEEEPARstart{A}{utonomous} systems are spreading not just in the virtual world (Internet, software systems), or in science-fiction movies, but in our ordinary real world. 
\IEEEPARstart{I}{t} is possible to find driverless cars in the streets, autonomous vacuum cleaners in our homes, autonomous robotic guides at museums, etc. These robotic systems, as any computer-based system, can suffer different types of cyber-attacks, and some degree of cybersecurity \cite{Morante2015} is required. 


Our research group is developing an assistant robot~\cite{Martin2014} for the elderly. When we initiated experiments involving potential users, caregivers asked us about the security of our robot and about the privacy of its communications \cite{Denning2009}. When an assistant robot carrying a camera is deployed in a home, the access to this camera should be secured; even more when the robot is managing medical information. 

We have developed all the software that controls the autonomous behavior of our robot using ROS (Robotic Operating System) \cite{ROS09} which has become the most popular framework for developing robotic applications. It started as a research framework, but currently most of manufacturers of commercial platforms use ROS as the {\em de facto} standard for building robotic software. For example, object-manipulation robots like Baxter (by Rethink robotics) ~\cite{fitzgerald2013developing} or service robots as our RB1 (by Robotnik) are ROS based platforms.

%We realized that the communication mechanism was one of its weakest points. 

%Some works have been sketched in this area, as for instance in \cite{Guiochet2016}.



\subsection{Security assessment}


There are three basic vulnerabilities threatening any computer system: availability (data interruption), confidentiality (data interception) and integrity (data modification). Other authors also add two more~\cite{sattarova2007security}: authenticity and non-repudiation (data fabrication from a non-trusted origin). 

These concepts can be easily translated to industrial control applications~\cite{huitsing2008attack} or to robotic environments, due to the distributed approach used in most extended robotic frameworks (Yarp, ROS, ROBOCOMP). On one hand, the robot is deployed in a home environment. The robot provides information to users and also carries out behaviors in order to fulfill required tasks. 

On the other hand, an attacker could attempt to make the robot or its network resources unavailable, this is a denial-of-service attack. The attacker could also intercept and modify command messages in order to change robot behavior, and capture robot information about the environment and about the users. Finally the attacker could simulate a sensor and generate new data and send it to the robot. Figure \ref{fig:Conceptualmodel} summarizes graphically these vulnerabilities in a robotic environment.

In this research we focus on confidentiality of data sent to and from the robot. Our proposal consists in encrypt data transmitted between ROS processes, adding two nodes for encryption and decryption task. We don't change ROS messages nor ROS standard functions to send the data. The question is if this hardening of ROS will impact on its performance.



% \begin{enumerate}
%  \item Availability: Interruption
%  \item Confidenciatily: Interception
%  \item Integrity: Modification
%  \item Authenticity: Fabrication
% \end{enumerate}
\begin{figure}[ht]
    \centering
    \includegraphics[width=.5\textwidth]{RobotsAttacks.pdf}
    \caption{Conceptual model of the security attacks.}
  \label{fig:Conceptualmodel}
\end{figure}


\subsection{ROS overview}

ROS provides specific libraries for robotics as well as classical operating system services such as hardware abstraction (for sensors and actuators), low-level device control, and inter-process communication. Inter-process communication is based on a graph architecture where computation takes place in ROS processes named nodes. These nodes can receive and send messages, but no security was considered in the communication mechanism.

ROS framework is basically a message-passing distributed system. Its architecture is based on processes that publish {\em messages} to {\em topics}. For instance, a process ({\em node}) can be in charge of accessing a sensor, performing the information processing, and publishing it as an information structure on a named topic. Another process can {\em subscribe} to this topic, that is, read its information. Then the process can make a decision about the movement of the robot. Next, this node will publish the commands in another topic to send them to the motors. ROS nodes can be running in the same computer or in different computers.

Conventional ROS environment is composed by at least one ROS Master and some clients. ROS Master is the key element in the ROS system. It runs as a nameservice and manages registration information of topics and services used by ROS nodes. 

When a node wants to stablish a connection with a topic, it communicates with Master to advise its registration information. After this step, the node gets more information about other registered nodes so it can stablish new connections with their topics appropriately. The Master is updated in real time with nodes information and topics they publish/subscribe.

% Nodes communicate with the Master to report their registration information. 
% As these nodes communicate with the Master, they can receive information about other registered nodes and make connections as appropriate. The Master will also make callbacks to these nodes when this registration information changes, which allows nodes to dynamically create connections as new nodes are run. 

The ROS distributed approach is very convenient for developers but can be easily tampered by malicious hackers. For instance, in \cite{McClean2013} an experiment involving a ROS-based honeypot is described. The honeypot was a radio model truck with two cameras and a compass as sensors, and it was controlled from a remote ROS node written in Javascript and hosted in a remote enterprise grade web server. Vulnerabilities described in the paper comprise plain-text communications, unprotected TCP ports and unencrypted data storage.

The first step to solve some of these problems is to secure the communication channels by using an encryption mechanism. But how does encryption impact on the performance of a robotic system? This is the goal of this paper, characterize and evaluate different alternatives to secure ROS communication system and measure their performance.


The paper is organized as follows: Next section describes the testbed we have designed to measure the performance of the encrypted ROS system. Third section evaluates the data obtained in the experiments, and last section presents some conclusions obtained and further work.



\section{Testbed description}

%%%  DESCRIPCIÓN DEL ESCENARIO
 
{\color{red}{Habr'ia que contar primero qu'e se quiere medir}} 
 
We prepared the following scenario to test the implementation of our approach.

%\textcolor{red}{TRADUCIR:} Un robot con un PC corriendo el master. Un sensor láser conectado al PC del robot. Un nodo de cifrado corriendo en el robot, que cifra los mensajes del láser y los publica en el topic "laser/encryted" (por ejemplo).
%Por otro lado, hay un PC cliente con ROS, que se registra en el master. Se suscribe al topic "laser/encryted" y como conoce la clave, es capaz de descifrar la información proporcionada por el láser.

First, we set up our robot RB1 installing ROS Indigo in its embedded computer. The master component was running in this platform. The robot was connected by cable to the network of our laboratory. We plugged a Hokuyo laser sensor to the robot. We launched the Hokuyo node that publishes laser data to the topic \textit{/laser}. Next we executed our encryption node which subscribes to \textit{/laser}, performs data encryption and publishes them into \textit{/encrypted/laser} topic.

Second, we used one desktop computer as a ``known client'', also with ROS Indigo installed and connected by cable to our network. This client knows the master ROS IP, so it can communicate with master. We run a decryption node in the client computer, which registers to master and subscribes to the topic \textit{/encrypted/laser}. This node decrypts data and prints them on the screen.

Third, we used another desktop computer as a simulated ``attacker'', connected to the same  cable network. This computer has the same ROS version running on it. The attacker doesn't know the master ROS IP, but he can easily discover it performing a network scan with known tools like \textit{nmap}. Then the attacker can execute a malicious node for attempting to read laser data, which is being published in the topic \textit{/encrypted/laser}. Despite the node could subscribe to that topic, all data received is encrypted. As a result, the malicious node can't see original laser messages because the attacker doesn't have the key to decrypt them. 

%Al mismo tiempo, un atacante desde otro PC con ROS, intenta hacer lo mismo. Escanea la red hasta dar con la IP del master y se registra. Pero gracias a nuestra soluci\'on, aunque se suscriba al topic para obtener los datos del l\'aser, no es capaz de ver nada legible porque no conoce la clave de descifrado.

\textcolor{red}{TRADUCIR:} Para las pruebas, la clave para cifrar/descifrar la tienen guardada tanto el master como el cliente conocido. En un sistema real, este proceso debería hacerse mediante un sistema de clave pública-privada como RSA, para transmitir de una forma segura la clave que van a compartir ambos nodos.

Figure~\ref{fig:TestBed} provides a graphical representation of the scenario created.
%In this case, two clients are connected to a topic. This situation is transparent to ROS Master.
%The standard process starts with a basic sensor node (BSN). We have defined as BSN those ROS nodes in charge of to publish the information from the sensor.
%We have prepared a testbed with two laptopts.


\begin{figure}[ht]
    \centering
    \includegraphics[width=.5\textwidth]{TestBed_complete.pdf}
    \caption{Scheme of the scenario used for testbed.}
  \label{fig:TestBed}
\end{figure}


%We have installed ROS Indigo in two computers connected through a wired Ethernet 10/100 switch (model XXXX).
%In the first computer we connected an Asus Xtion camera and a Hokuyo laser sensor. The second computer was running a node for visualizing the sensors information sent by first computer. %Figure \ref{fig:maqueta} shows this environment.

% Then we modified the standard ROS implementation. We changed the TCP/IP sockets based implementation by ciphered ones.


\subsection{Encrypting ROS messages}

%%%  DESCRIBIR SISTEMA DE CIFRADO QUE USAMOS

% Decir que: SÓLO HEMOS AÑADIDO CIFRADO Y DESCIFRADO EN LOS NODOS EMISORES Y RECEPTORES. NO HEMOS MODIFICADO EL SISTEMA DE BAJO NIVEL DE ROS, PARA EVALUAR ESPECÍFICAMENTE Y DE UNA FORMA MÁS PRECISA LA CARGA QUE SUPONE EL CIFRADO EN LOS NODOS.

In this first approach we have changed the data published by the node, and instead of publish the information in a plain manner, we publish the information encrypted. We use the 3DES algorithm that provides a security layer to protect data.
Triple DES (3DES) references the Triple Data Encryption Algorithm (TDEA or Triple DEA). It is a symmetric-key block cipher that applies the Data Encryption Standard (DES) algorithm three times to each data block. It is standardized by NIST in the Recommendation for the Triple Data Encryption Algorithm Block Cipher (NIST Special Publication 800-67).

DES algorithm has a fixed data block size of 8 bytes. Its keys are 128 (option 1) or 192 bits (option 2) long. However, 1 out of 8 bits is used for redundancy and do not contribute to security. The effective key length is respectively 112 or 168 bits.

The plaintext is first encrypted with K1, then decrypted with K2, and finally encrypted again with K3. The ciphertext is decrypted in the reverse manner.

The 192 bit key is a bundle of three 64 bit independent subkeys: K1, K2, and K3.

The 128 bit key is split into K1 and K2, whereas K1=K3.

It is important that all subkeys are different, otherwise 3DES would degrade to single DES.

3DES is cryptographically secure, although it is slower than AES algorithm. In a next stage, we will substitute 3DES with AES in our encryption system and repeat all the test we have done, to compare the performance.






\section{Experimental Measurements}

\textcolor{red}{A\~NADIR EL MODELO DE SWITCH EN ESTA SECCI\'ON}

To illustrate the described approach, we present an ad-hoc implementation of an encryption system to change part of the message used for transmit or receive robot sensors information. 
We maintain in each case 

% Figure \ref{fig:velocidad-maqueta} shows the maximum rate that can be reached both in the laser and the camera visualization according to \texttt{rviz} information.

The same measurements were made in the second environment to see whether the use of wireless systems and a real robot have any impact.

% The absolute values of the frame rates is obviously different, as shown in figure \ref{fig:velocidad-robot}. But the interesting part is the relative different when using clear communications or ciphered ones. 

% Table \ref{tab:relativas}  compares the relative reduction of speed when using ciphered protocols vs clear ones in both environments as well as the relative increase of CPU usage.

%The decorator pattern can be used to extend (decorate) the functionality of a certain object statically, or in some cases at run-time, independently of other instances of the same class, provided some groundwork is done at design time. 
We have added a function to our program in order to measure the time spent on each encryption and decryption call. The function is a python method presented as a decorator pattern, which is used here to extend the functionality of encryption/decryption at run-time. 


{
  \footnotesize{
    \begin{Verbatim}[frame=single]
def fn_timer(function):
	  @wraps(function)
	  def function_timer(*args, **kwargs):
	      v_time_0 = time.time()
	      result = function(*args, **kwargs)
	      v_time_1 = time.time()
	      return result
	  return function_timer
    \end{Verbatim}
  }
}

We have divided the experiments in three parts. First we have analyzed how does the "talker-listener" simple ROS node works under encrypted conditions. Then we have stressed the same node publishing-subscribing bigger text messages. Finally we have analyzed a real sensor, a camera, under crypted conditions in order to analize the system behaviour under encrypting conditions.  

\subsection{Hardware Used}

\textcolor{red}{COMENTAR A ALTO NIVEL QU\'E/CU\'ANTAS PRUEBAS HEMOS HECHO.}

We want to evaluate how the encryption of communications would affect the performance of ROS.
In this first approach we have used two  Alcatel-Lucent OmniSwitch 6860E de 48 puertos PoE+ (OS6860E-P48)
second experiment we changed the first computer for a RB1 robot and the XXX switch by a wireless one. The robot was also running ROS Indigo.



\subsection{Test 1: Talker-Listener Node}

In this test we have used the version of talker/listener tutorial proposed by ROS\footnote{\url{http://wiki.ros.org/rospy_tutorials/Tutorials/WritingPublisherSubscriber}}

This package distributed by ROS as a demo, presents a simple ROS package that creates two rospy nodes. The "talker" node broadcasts a {\em Hellow world + Timestamp} message on topic "chatter", while the "listener" node receives and prints the message.


%======================================
%Cifrado
%======================================
%Cifrado length: 1272.000000
%Cifrado min: 0.000040
%Cifrado max: 0.000129
%Cifrado mean: 0.000065
%Cifrado stdev: 0.000000
%El valor moda de la fase de cifrado fue:
%(array([  4.60147858e-05]), array([ 55.]))
%======================================
%Descifrado
%======================================
%Cifrado length: 1570.000000
%Cifrado min: 0.000023
%Cifrado max: 0.000239
%Cifrado mean: 0.000045
%Cifrado stdev: 0.000000
%El valor moda de la fase de cifrado fue:
%(array([  4.50611115e-05]), array([ 260.]))

Table~\ref{tab:time_simple_text_hellow_CPU} presents the CPU time spent when the nodes are running in different machines.  The values are the result of launching ROS nodes using the Unix command {\em time}. The values present a minimal consumption of CPU associated to the process. In  case of Plain publish/subscribe it represents than 1\% and in the case of the publisher in encrypt mode it represents approximately the 1.1\%, that is almos the same than in plain mode.

%\begin{figure}[ht!]
%	\centering
%	\includegraphics[width=.5\textwidth]{Text_plain_vs_encrypted.png}
%	\caption{Time of CPU spent on a simple publisher/listener 30 seconds running test.}
%	\label{fig:time_simple_text_hellow_CPU}
%\end{figure}

\begin{table}[h]
	\centering
	\caption{Time in seconds of CPU spent on a simple publisher/listener running test.}
	\label{tab:time_simple_text_hellow_CPU}
	\begin{tabular}{|l|l|l|l|l|}
		\hline
&		Plain&	Plain&	Encrypt&	Decrypt \\
&		Publication&Subscription&Publication&Subscription \\\hline
Time running&34.491&	34.484&	36.882&	34.995 \\\hline
Time user&0.184&	0.196&	0.348&	0.24 \\\hline
Time sys&0.024&	0.08&	0.064&	0.056 \\\hline
Total CPU&0.208&	0.276&	0.412&	0.296 \\\hline

	\end{tabular}
\end{table}

Figure~\ref{fig:time_simple_text_CPU} presents the boxplot associated to the calls to encrypt/decrypt methods used in this paper. It was used the PyCrypto package, it is an extended python Cryptography Toolkit that allows to simply the method to encrypt or decrypt in multiple languages. In this case we have cyphered using 3DES.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=.5\textwidth]{figure_Simple_Publisher_subscriber.png}
	\caption{Time spent on a encrypt/decrypt DES3 function call.}
	\label{fig:time_simple_text_CPU}
\end{figure}


\begin{figure*}[ht!]
	\centering
	\includegraphics[width=.99\textwidth]{Screenshot_hello_world.png}
	\caption{Screenshot with the nodes involved in the simple publisher/subscribe test. Upper left terminal presents the publisher node before encryption. Botton left terminal depicts the subscriber node after decruption. Right terminal presents the results of rostopic echo on {\em /chatter} topic used for transmitting info through nodes.}
	\label{fig:screenshot_hello_world}
\end{figure*}

\subsection{Test 2: Custom Talker-Listener Node}


In this test we have used a modified version of talker/listener tutorial proposed by ROS. 
ROS statistical data shows the simple publish/subscribe example sending 11 string messages ({\em std\_msgs/String}) per second (with ``Hello wold'' text), plus a timestamp with 440 bytes of traffic.
In this manner, we wanted to analyse the behaviour of the system using bigger messages: T1, 262144 bytes (256 KB); T2, 524288 bytes (512 KB); and T3, 1048576 bytes (1024 KB).

The measurements of behaviour of ROS traffic presents with simple plain messages {\em delivered\_msgs} 10 of T1 generate . When T2 messages are sent the system runs with 4194368 bytes of traffic and finally when it is working in  T3 messages just send 4194336 bytes and a total of 4 messages. There is no dropped messages by subscription.

We want to determine the duration of execution of our talker. We run the Linux {\em time} command to measure the total CPU time consumed by the ROS talker process. 
Firstly we analyzed T1, that presents in a time window of 32.884 seconds, a user time of  1.364 seconds and a sys time of 0.044s. It represents a CPU time of 1.408 seconds.
Secondly we analyzed T2, that presents in a time window of 33.749 seconds, a user time of  2.508 seconds and a sys time of 0.164s. It represents a CPU time of 2.672 seconds.
Finally we analyzed T3, that presents in a time window of 34.731 seconds, a user time of  5.140 seconds and a sys time of 0.120s. It represents a CPU time of 5.260 seconds.

This is totally different when we are working with encrypted text messages of type T1, T2 or T3. Fig~\ref{fig:time_text_CPU} presents the main differences. We have repeated the same experiment, but this time calling an encryption method that encrypts from plain text to 3DES. It is possible to see that the encrypt process consumes more CPU than  the plain process.
For instance, T1 type presents running for 34.486 seconds a total of 23.008 of CPU. This means that the total CPU time increases almost 62\%. This is even higher in T2 and T3 types with almost the 98\% of real execution time.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=.5\textwidth]{Text_plain_vs_encrypted.png}
    \caption{Time of CPU spent on a simple talker/listener test.}
  \label{fig:time_text_CPU}
\end{figure}

\textcolor{red}{[REESCRIBIR BIEN ESTE P\'ARRAFO].} If we focus on the encryption/decryption process, we can see that the time needed for the encryption function shows in 1040 messages a minimal time of 0.059246 seconds and a max time to encrypt the string of 0.683408 seconds with an average of 0.063858 seconds and standard deviation of 0.000388.

This time increases with T2 and T3 types. T2 type needs 0.123383 seconds in average with standard deviation of 0.000040 seconds and  T3  0.247303 with a standard deviation of 0.000137.



% raspberry@david-H97M-D3H:~/catkin_ws/src/security_repo/ciphering_project/simple_talker_listener/src$ time python talker3DES.py
% ;;;;;;;;
% ^C
% real    0m34.486s
% user    0m22.924s
% sys    0m0.084s
% raspberry@david-H97M-D3H:~/catkin_ws/src/security_repo/ciphering_project/simple_talker_listener/src$ time python talker3DES.py
% ;;;;;;;;
% ^C
% real    0m40.607s
% user    0m40.368s
% sys    0m0.232s
% raspberry@david-H97M-D3H:~/catkin_ws/src/security_repo/ciphering_project/simple_talker_listener/src$ time python talker3DES.py
% ;;;;;;;;
% ^C
% real    0m38.718s
% user    0m38.416s
% sys    0m0.248s



% where 0m34.731s of execution 
% user    0m5.140s
% sys    0m0.120s
% 
% raspberry@david-H97M-D3H:~/catkin_ws/src/security_repo/ciphering_project/simple_talker_listener/src$ time python talker.py
% ^C
% real    0m33.749s
% user    0m2.508s
% sys    0m0.164s
% 
% raspberry@david-H97M-D3H:~/catkin_ws/src/security_repo/ciphering_project/simple_talker_listener/src$ time python talker.py
% ^C
% real    0m32.884s
% user    0m1.364s
% sys    0m0.044s
% ======================================
% 256
% ======================================
% Cifrado length: 1040.000000
% Cifrado min: 0.059246
% Cifrado max: 0.683408
% Cifrado mean: 0.063858
% Cifrado stdev: 0.000388
% El valor moda de la fase de cifrado fue:
% (array([ 0.06053495]), array([ 3.]))
% ======================================
% 512
% ======================================
% Cifrado length: 309.000000
% Cifrado min: 0.120618
% Cifrado max: 0.229785
% Cifrado mean: 0.123383
% Cifrado stdev: 0.000040
% El valor moda de la fase de cifrado fue:
% (array([ 0.12165689]), array([ 2.]))
% ======================================
% 1024
% ======================================
% Descifrado length: 147.000000
% Descifrado min: 0.242966
% Descifrado max: 0.386008
% Descifrado mean: 0.247303
% Descifrado stdev: 0.000137
% El valor moda de la fase de descifrado fue:
% (array([ 0.24460196]), array([ 2.]))



\subsection{Test 3: Camera Node}


\subsubsection{Process evaluation}

We have used a Logitech, Inc. QuickCam Pro 9000 webcam.

There are three nodes involved in our system: usb\_cam, encrypted\_node and decrypted\_node. The first and the sencond run in the master computer, the decrypted one in a separate computer.

There are three topics involved: \textcolor{red}{[COMPLETAR]}

To analyse the behaviour of the system under encrypt/decrypt circumstances we use an Intel i7 computer with 16 GB RAM. The ROS master system has 234 process running by default in a Ubuntu 14.04, the client is running 242 process in the same operative system.

\begin{figure}[ht]
    \centering
    \includegraphics[width=.5\textwidth]{Screenshot.png}
    \caption{Screenshot taken during image encryption test.}
  \label{fig:screenshot}
\end{figure}

In this case we measure the time needed to encrypt or decrypt the ROS message ({\em sensor\_msgs/Image.msg}). We just encrypt or decrypt the field data of {\em uint8[]} that is treated as a string.
To evaluate  the frame rate, our nodes present this information during the execution in the visualization frame . 

This experiment was running for about 18 hours sending in total 971790 frames. The minimal time to encrypt the images was 0.001309 seconds, the max time  0.026909 seconds with a 
mean of  0.010948 seconds and a standard deviation of 0.000004 seconds. The mode value in this phase was 0.010571 seconds wich was reapeated 415 times. 

The minimal time to decrypt the images was 0.001288 seconds, the max time was 0.039130 seconds with a 
mean of  0.008828 seconds and a standard deviation of 0.000003 seconds. The mode value in this phase was 0.008183 seconds wich was reapeated 593 times. 



Figure \ref{fig:screenshot} presents the situation in the client node. We have used the ROS node {\em image\_view} to visualize the images from topics.  There is an non-encrypted topic that we have maintained in order to validate delays. There is an encrypted topic that is not possible to visualize using the released image\_view ROS node. Finally there is a frame that presents the image after decrypt the topic using our own decrypt node. 


The FPS in the encrypter machine is 14.56 and the FPS in the decryption machine is 14.54.



\begin{figure*}[ht]
    \centering
    \includegraphics[width=.9\textwidth]{Outline_encryption_text.png}
    \caption{Time spent on each call to encryption/decryption function.}
  \label{fig:text_encryption_time}
\end{figure*}


\section{Discussion}

Fig~\ref{fig:text_encryption_time} outlines the behaviour of the talker cyphering data. Left part of the figure presents the box plot of the three types of message. The right part of the element present the number of repetition associated to a time to each encryption process.


We observe that the delay induced by encryption does not reduce the standard frame rate. 

The figure~\ref{fig:images_encryption} presents the box-plot of the encryption decryption data analyzed and the histograma. 

\begin{figure*}[ht]
    \centering
    \includegraphics[width=.9\textwidth]{Outline_images_encryption_decrytiontime2.png}
    \caption{Time spent on each call to encryption/decryption function.}
  \label{fig:images_encryption}
\end{figure*}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Camara
% *****************************************************
% load avg
% *****************************************************
% 1m
% Cifrado length: 73583.000000
% Cifrado min: 0.000000
% Cifrado max: 4.090000
% Cifrado mean: 0.420771
% Cifrado stdev: 0.402261
% El valor moda del elemento 1m: (array([ 0.01]), array([ 2720.]))
% 5m
% Cifrado length: 73583.000000
% Cifrado min: 0.070000
% Cifrado max: 1.330000
% Cifrado mean: 0.420862
% Cifrado stdev: 0.062276
% El valor moda del elemento 5m: (array([ 0.27]), array([ 2261.]))
% 15m
% Cifrado length: 73583.000000
% Cifrado min: 0.190000
% Cifrado max: 0.710000
% Cifrado mean: 0.420539
% Cifrado stdev: 0.009572
% El valor moda del elemento 15m: (array([ 0.39]), array([ 3407.]))
% 
% 
% 
% *****************************************************
% net/eth0
% *****************************************************
% recv
% Cifrado length: 73583.000000
% Cifrado min: 0.000000
% Cifrado max: 2894889.000000
% Cifrado mean: 180.865336
% Cifrado stdev: 152873314.363260
% El valor moda del elemento recv: (array([ 0.]), array([ 39574.]))
% send
% Cifrado length: 73583.000000
% Cifrado min: 0.000000
% Cifrado max: 16727.000000
% Cifrado mean: 0.987021
% Cifrado stdev: 9843.397769
% El valor moda del elemento send: (array([ 0.]), array([ 73511.]))
% 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Idle PC
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

% *****************************************************
% net/eth0
% *****************************************************
% recv
% Cifrado length: 73950.000000
% Cifrado min: 0.000000
% Cifrado max: 2429716.000000
% Cifrado mean: 199.616822
% Cifrado stdev: 134166979.708237
% El valor moda del elemento recv: (array([ 0.]), array([ 34878.]))
% send
% Cifrado length: 73950.000000
% Cifrado min: 0.000000
% Cifrado max: 14811.000000
% Cifrado mean: 23.408343
% Cifrado stdev: 12934.495778
% El valor moda del elemento send: (array([ 0.]), array([ 64845.]))
% 
% *****************************************************
% load avg
% *****************************************************
% 1m
% Cifrado length: 73950.000000
% Cifrado min: 0.000000
% Cifrado max: 4.520000
% Cifrado mean: 0.310385
% Cifrado stdev: 0.599820
% El valor moda del elemento 1m: (array([ 0.]), array([ 41293.]))
% 5m
% Cifrado length: 73950.000000
% Cifrado min: 0.020000
% Cifrado max: 1.360000
% Cifrado mean: 0.311375
% Cifrado stdev: 0.094693
% El valor moda del elemento 5m: (array([ 0.04]), array([ 5726.]))
% 15m
% Cifrado length: 73950.000000
% Cifrado min: 0.130000
% Cifrado max: 0.620000
% Cifrado mean: 0.311785
% Cifrado stdev: 0.012632
% El valor moda del elemento 15m: (array([ 0.22]), array([ 3330.]))



\section{Conclusion and Further Work}

This article has introduced the use of encrypted information through ROS communication system.
We have evaluated the impact of this added feature from two points of view: CPU consuming and network traffic. 

We have shown that our approach avoids security problems related with the plain-text publish/subscribe paradigm used by ROS. However, the overhead of CPU performance and communication load should also be considered in distributed architectures that need to work on real time.

As we pointed out in the introduction, securing communications is just one dimension in the cybersecurity of autonomous systems. If we want to see these machines working in our homes we need to secure navigation abilities and interaction mechanisms, to avoid manipulated or malicious behaviours and make robots reliable assistants for every person at home.


\section*{Acknowledgment}
The authors would like to thank the Spanish Ministry of Economy and Competitiveness for the partial support to this work under grant DPI2013-40534-R and to the Spanish National Institue of CyberSecurity (INCIBE) under grand Adenda21 ULE-INCIBE.

\bibliographystyle{plain} 
\bibliography{waf2016}

\end{document}

